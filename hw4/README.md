# Общее описание
## Задание
Разработать ассемблер и интерпретатор для учебной виртуальной машины
(УВМ). Система команд УВМ представлена далее.

Для ассемблера необходимо разработать читаемое представление команд
УВМ. Ассемблер принимает на вход файл с текстом исходной программы, путь к
которой задается из командной строки. Результатом работы ассемблера является
бинарный файл в виде последовательности байт, путь к которому задается из
командной строки. Дополнительный ключ командной строки задает путь к файлу-логу, в котором хранятся ассемблированные инструкции в духе списков
“ключ=значение”.

Интерпретатор принимает на вход бинарный файл, выполняет команды УВМ
и сохраняет в файле-результате значения из диапазона памяти УВМ. Диапазон
также указывается из командной строки.

Форматом для файла-лога и файла-результата является json.

Необходимо реализовать приведенные тесты для всех команд, а также
написать и отладить тестовую программу
# Команды ассемблера

Аккумулятор — регистр процессора, в котором сохраняются результаты выполнения арифметических и логических команд.

## Загрузка константы
| A | B |
| :---: | :---: | 
| Биты 0-3 | Биты 4-24 |
| 9 | Константа |

Размер команды: 4 байт.

Операнд: поле B.

Результат: регистр-аккумулятор.

## Чтение значения из памяти
|    A     |     B     |
|:--------:|:---------:| 
| Биты 0-3 | Биты 4-11 | 
|    5     | Смещение  | 

Размер команды: 4 байт.

Операнд: значение в памяти по адресу, которым является сумма адреса (регистр-аккумулятор) и смещения (поле B).

Результат: регистр-аккумулятор.

## Запись значения в память
|    A     |     B     |
|:--------:|:---------:| 
| Биты 0-3 | Биты 4-26 |
|    4     |   Адрес   |

Размер команды: 4 байт.

Операнд:  регистр-аккумулятор.

Результат: Результат: значение в памяти по адресу, которым является поле B.

## Бинарная операция: побитовый циклический сдвиг влево
|    A     |     B     |
|:--------:|:---------:|
| Биты 0-3 | Биты 4-26 |
|    11    |   Адрес   |

Размер команды: 4 байт.

Первый операнд: регистр-аккумулятор. 
Второй операнд: значение в памяти по адресу, которым является поле B. 
Результат: регистр-аккумулятор.

# Задание №4: Разработать ассемблер и интерпретатор для учебной виртуальной машины (УВМ)

Для ассемблера необходимо разработать читаемое представление команд УВМ.

Ассемблер принимает на вход файл с текстом исходной программы, путь к
которой задается из командной строки. Результатом работы ассемблера является
бинарный файл в виде последовательности байт, путь к которому задается из
командной строки. Дополнительный ключ командной строки задает путь к файлу-
логу, в котором хранятся ассемблированные инструкции в духе списков
“ключ=значение”, как в приведенных далее тестах.


Интерпретатор принимает на вход бинарный файл, выполняет команды УВМ
и сохраняет в файле-результате значения из диапазона памяти УВМ. Диапазон
также указывается из командной строки.


Форматом для файла-лога и файла-результата является xml.
Необходимо реализовать приведенные тесты для всех команд, а также
написать и отладить тестовую программу.

---

### Загрузка константы

| A        | B         | C          | 
|----------|-----------|------------|
| Биты 0—6 | Биты 7—19 | Биты 20—47 | 
| 36       | Адрес     | Константа  |

Размер команды: 6 байт. 

Операнд: поле C. 

Результат: значение в памяти по адресу, которым является поле B.

Тест (A=36, B=736, C=12):

0x24, 0x70, 0xC1, 0x00, 0x00, 0x00

---

### Чтение значения из памяти

| A        | B         | C          | D          |
|----------|-----------|------------|------------| 
| Биты 0—6 | Биты 7—19 | Биты 20—32 | Биты 33—38 |
| 58       | Адрес     | Адрес      | Смещение   |

Размер команды: 6 байт. 

Операнд: значение в памяти по адресу, которым является сумма адреса (значение в памяти по адресу, которым является поле C) и
смещения (поле D). 

Результат: значение в памяти по адресу, которым является поле B.

Тест (A=58, B=405, C=198, D=36):

0xBA, 0xCA, 0x60, 0x0C, 0x48, 0x00

---

### Запись значения в память

| A        | B         | C          | 
|----------|-----------|------------|
| Биты 0—6 | Биты 7—19 | Биты 20—32 | 
| 25       | Адрес     | Адрес      |

Размер команды: 6 байт. 

Операнд: значение в памяти по адресу, которым является поле B. 

Результат: значение в памяти по адресу, которым является поле C.

Тест (A=25, B=919, C=959):

0x99, 0xCB, 0xF1, 0x3B, 0x00, 0x00

---

### Бинарная операция: умножение


| A        | B         | C          | D          |
|----------|-----------|------------|------------| 
| Биты 0—6 | Биты 7—19 | Биты 20—32 | Биты 33—45 |
| 32       | Адрес     | Адрес      | Адрес      |

Размер команды: 6 байт. 

Первый операнд: значение в памяти по адресу, которым является поле D.

Второй операнд: значение в памяти по адресу, которым является поле C.

Результат: значение в памяти по адресу, которым является поле B.

Тест (A=32, B=866, C=372, D=368):

0x20, 0xB1, 0x41, 0x17, 0xE0, 0x02

### Тестовая программа
Выполнить поэлементно операцию умножение над двумя векторами длины 7.
Результат записать в первый вектор.

# Описание всех функций и настроек
### Класс Assembler

#### `Assembler __init__(self)
```Python
     def __init__(self):
        # команды виртуальной машины(УВМ) и
        # их соответствующие значения
        # в формате шестнадцатеричных кодов(опкодах)
        self.instructions = {
            'LOAD_CONST': 0x9,
            'READ': 0x5,
            'WRITE': 0x4,
            'ROTATE_LEFT': 0xB
        }
        self.binary_code = []
```
- **Описание**: Конструктор класса
---

#### `assenble`
```Python
        def assemble(self, input_file, output_file, log_file):
        with open(input_file, 'r') as f:
            lines = f.readlines()
        logs = []
        for line in lines:
            parts = line.strip().split()
            if len(parts)==0 or line.startswith(';'):  # Игнорируем пустые строки и комментарии
                continue
            command = parts[0]
            if command in self.instructions:
                a = int(parts[1])# Значение A
                b = int(parts[2])# Значение B
                if (command=='LOAD_CONST' and not (0 <= b < (1 << 21))):
                    raise ValueError("Константа B должен быть в пределах от 0 до 2^23-1")
                elif (command in ['WRITE', 'ROTATE_LEFT'] and not (0 <= b < (1 << 23))):
                    raise ValueError("Смещение B должен быть в пределах от 0 до 2^23-1")
                elif (command=='READ' and not (0 <= b < (1 << 8))):
                    raise ValueError("Смещение B должен быть в пределах от 0 до 2^8-1")
                # Формируем бинарный код команды
                instruction = (b << 4) | a

                instruction = instruction.to_bytes(4, byteorder='little')
                logs.append({"command": line.rstrip(), "binary": str(instruction)})
                self.binary_code.append(instruction)
            else:
                print('Команда не найдена')
                return

        # Запись бинарного файла
        with open(output_file, 'wb') as f:
            for instruction in self.binary_code:
                f.write(instruction)

        # Запись лог-файла
        with open(log_file, 'w') as log_f:
            json.dump(logs, log_f, indent=4)

```
- **Описание**: функция для кодирования операций
- - **Параметры**:
  - `input_file`: путь до кода программы
  - `output_file`: путь до выходного бинарного файла
  - `log_file`: путь до файла с логами
---


### Класс Interpreter

#### `__init__(self, memory_size=1024)`
```Python
    def __init__(self, memory_size=1024):
        self.memory = [0] * memory_size  # Эмуляция памяти
        self.accumulator = 0  # Регистр-аккумулятор
```
- **Описание**: Конструктор класса


#### `load_constant`
```Python
    def execute(self, binary_file, output_file, memory_range):
        byte_code = 0
        with open(binary_file, 'rb') as f:
            byte_code = int.from_bytes(f.read(), byteorder="little")

        while byte_code !=0:
            a = byte_code & ((1 << 4) -1 )
            byte_code >>= 4
            match a:
                case 9:#LOAD_CONSTANT
                    self.accumulator = byte_code & ((1 << 21)-1)
                case 5:#READ
                    offset = byte_code & ((1 << 8) -1)
                    self.accumulator = self.memory[self.accumulator+offset]
                case 4:#WRITE
                    address = byte_code & ((1 <<23)-1)
                    self.memory[address] = self.accumulator
                case 11:#ROTATE_LEFT
                    address = byte_code & ((1 << 23) - 1)
                    shift = self.memory[address]
                    self.accumulator = ((self.accumulator << shift) & ((1 << 21)-1)) | (self.accumulator >> (21 - shift))
                    #Сдвигаем число влево и обрезаем его до нужного количества бит, используя маску (1 << bits) - 1.
                    # Эта маска устанавливает все биты в 1 до bits.
                    #Комбинируем сдвинутое число с правым сдвигом исходного числа, который возвращает старшие биты в младшие позиции.
                case _:
                    raise ValueError("В бинарном файле содержатся невалидные данные: неверный байт-код")
            byte_code >>= 28



        # Записываем результаты в json
        result = {
            "memory_range": self.memory[memory_range[0]:memory_range[1]],
            "accumulator": self.accumulator
        }

        # Сохранение результата в выходной файл
        with open(output_file, 'w') as f:
            json.dump(result, f, indent=4)

```
- **Описание**: функция для выполнения операций и записи результата в файл.
- **Параметры**:
  - `binary_file`: путь до кода программы
  - `memory_range`: границы памяти
  - `output_file`: путь до файла с результатом
---


# Сборка и запуск проекта
1. Загрузить репозиторий на компьютер
```
git clone https://github.com/senya1101/config
```
2. Прейдите в директорию репозитория
```
cd hw4
```
3. Запустить assembler.py с указанием исполняемой программы, бинарного файла вывода и лог-файла
```
py src/assembler.py <исполняемая_программа.asm> <бинарный_файл_вывода.bin> -l <лог-файл.json>
```
4. Запустить interpreter.py с указанием бинарного файла данных, файла с результатами и диапазона памяти
```
py src/interpreter.py <бинарный_файл_данных.bin> <результат.json> -lb <левая_граница_диапазона> -rb <правая граница диапазона>
```
# Примерs работы программы
### Задание для тестовой программы
Выполнить поэлементно операцию побитовый циклический сдвиг влево над двумя векторами длины 8. Результат записать в первый вектор.
### Тестовая программа
```
LOAD_CONST 9 20
WRITE 4 0
LOAD_CONST 9 3
ROTATE_LEFT 11 0
WRITE 4 0

LOAD_CONST 9 20
WRITE 4 1
LOAD_CONST 9 2
ROTATE_LEFT 11 1
WRITE 4 1

LOAD_CONST 9 2
WRITE 4 2
LOAD_CONST 9 2
ROTATE_LEFT 11 2
WRITE 4 2

LOAD_CONST 9 3
WRITE 4 3
LOAD_CONST 9 3
ROTATE_LEFT 11 3
WRITE 4 3

LOAD_CONST 9 4
WRITE 4 4
LOAD_CONST 9 4
ROTATE_LEFT 11 4
WRITE 4 4

LOAD_CONST 9 5
WRITE 4 5
LOAD_CONST 9 5
ROTATE_LEFT 11 5
WRITE 4 5

LOAD_CONST 9 6
WRITE 4 6
LOAD_CONST 9 6
ROTATE_LEFT 11 6
WRITE 4 6

LOAD_CONST 9 7
WRITE 4 7
LOAD_CONST 9 7
ROTATE_LEFT 11 7
WRITE 4 7
```
### Данные, записанные в лог-файл
```
[
    {
        "command": "LOAD_CONST 9 20",
        "binary": "b'I\\x01\\x00\\x00'"
    },
    {
        "command": "WRITE 4 0",
        "binary": "b'\\x04\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 3",
        "binary": "b'9\\x00\\x00\\x00'"
    },
    {
        "command": "ROTATE_LEFT 11 0",
        "binary": "b'\\x0b\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 0",
        "binary": "b'\\x04\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 20",
        "binary": "b'I\\x01\\x00\\x00'"
    },
    {
        "command": "WRITE 4 1",
        "binary": "b'\\x14\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 2",
        "binary": "b')\\x00\\x00\\x00'"
    },
    {
        "command": "ROTATE_LEFT 11 1",
        "binary": "b'\\x1b\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 1",
        "binary": "b'\\x14\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 2",
        "binary": "b')\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 2",
        "binary": "b'$\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 2",
        "binary": "b')\\x00\\x00\\x00'"
    },
    {
        "command": "ROTATE_LEFT 11 2",
        "binary": "b'+\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 2",
        "binary": "b'$\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 3",
        "binary": "b'9\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 3",
        "binary": "b'4\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 3",
        "binary": "b'9\\x00\\x00\\x00'"
    },
    {
        "command": "ROTATE_LEFT 11 3",
        "binary": "b';\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 3",
        "binary": "b'4\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 4",
        "binary": "b'I\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 4",
        "binary": "b'D\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 4",
        "binary": "b'I\\x00\\x00\\x00'"
    },
    {
        "command": "ROTATE_LEFT 11 4",
        "binary": "b'K\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 4",
        "binary": "b'D\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 5",
        "binary": "b'Y\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 5",
        "binary": "b'T\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 5",
        "binary": "b'Y\\x00\\x00\\x00'"
    },
    {
        "command": "ROTATE_LEFT 11 5",
        "binary": "b'[\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 5",
        "binary": "b'T\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 6",
        "binary": "b'i\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 6",
        "binary": "b'd\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 6",
        "binary": "b'i\\x00\\x00\\x00'"
    },
    {
        "command": "ROTATE_LEFT 11 6",
        "binary": "b'k\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 6",
        "binary": "b'd\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 7",
        "binary": "b'y\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 7",
        "binary": "b't\\x00\\x00\\x00'"
    },
    {
        "command": "LOAD_CONST 9 7",
        "binary": "b'y\\x00\\x00\\x00'"
    },
    {
        "command": "ROTATE_LEFT 11 7",
        "binary": "b'{\\x00\\x00\\x00'"
    },
    {
        "command": "WRITE 4 7",
        "binary": "b't\\x00\\x00\\x00'"
    }
]
```
### Данные, записанные в файл-результат
```
{
    "memory_range": [
        1048577,
        1,
        8,
        24,
        64,
        160,
        384,
        896
    ],
    "accumulator": 896
}
```

## Результаты тестирования
![image](https://github.com/senya1101/config/blob/images/hw4/imgs/test.png?raw=true)
